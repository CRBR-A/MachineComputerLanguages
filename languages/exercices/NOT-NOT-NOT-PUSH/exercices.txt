6. **[chess](chess.md) [AI](ai.md)**: Use any sane approach to write a chess engine of reasonable strength. No, you can't just fork stockfish, write it from scratch. It has to support xboard or UCI interface, the strength must be such that in usually wins at least once in a 10 game match against [smolchess](smallchesslib.md), Maia 1500, GNU chess, Dreamer, ChessMaster, Stockfish or similar engine with equivalent settings (search depth, time for move etc.); alternatively it can pass by getting stable rating over 1600 on lichess or by beating someone with FIDE rating over 1500 in a 10 game match. You get the idea.

15. **language recognizer**: Make a program that will be able to learn and then recognize language of text it is given (in theory it should work for any kind of language, be it human or computer language). Specifically the program will first get *N* files, each one representing a different language (e.g. 5 books in different human languages), then it will take some other text and say to which of the initial *N* files it is linguistically most similar. For simplicity assume only plain ASCII files on input (you can just use some Unicode to ASCII utility on all input files). Use some simple [machine learning](machine_learning.md) technique such as some variant of k-NN. It will suffice if for each training example you construct a vector of some nice features, for example {average word length, vowel/consonant ratio, relative frequency of letter A, relative frequency of letter E, ...}, give each component some weight and then just find the nearest neighbour to the tested sample in this feature space (if you want to be more fancy, split the input files into parts so you get more training samples, then try k-NN with some convenient k). You shouldn't and CANNOT use neural networks, and of course you CANNOT use any machine learning library ;) You don't have to achieve great accuracy but your program should likely be able to quite reliably tell e.g. German from C++.


## Advance 


2. small interpreter: 
  - input: a code or a filename
  - output: show the result of the input
  

Library: 2D
2. 2D game:


3. **3D game**: Make a complete game with 3D graphics from 1st or 3rd man perspective that will have at least half an hour worth of gameplay time -- the gameplay can really be 2D (e.g. like [wolf3D](wolf3d.md)) but the graphics must be judged as 3D by average guy who sees the game. If your platform allows it at all, it must have basic sounds (no need for music, but e.g. shooting should at least make beeps and so on). The genre is up to you, it can be a shooter, platformer, RPG or anything where you control a character. For the 3D graphics you can either use a 3D library, in which case you HAVE TO implement textured graphics (the textures may be [procedural](procgen.md) if you want), or you can write your own renderer. If you write custom renderer, then if it's a "true 3D", it can have just flat, untextured graphics; if it's a "[pseudo 3D](pseudo3d.md)" (like raycasting or BSP, ...), it must have at least some texturing (e.g. walls).




Huge:
1. **3D [physics engine](physics_engine.md) without [floating point](float.md)**: Warm up for the god tier by making a 3D physics engine without using floating point, usable in real time. It must support complex shapes, i.e. not just plain spheres ;) The engine can use rigid body or soft body physics, or both. It doesn't have to be physically accurate but should produce results that an average observer will judge realistic enough for a game.
2. **[operating system](operating_system.md)**: Make a whole [self hosted](self_hosting.md) operating system with your own custom kernel, with basic [GUI](gui.md) and tools such as a text editor, file browser and programming language compiler. Throw in some games because without them your OS will be boring. Run the OS on real hardware. It doesn't have to support networking, sound, USB and similar bloat, but thumbs up if you manage even that.


5. **the grandest program of all time**: Make a program that (in a simplified way but still) simulates the whole [Universe](universe.md) and allows its user to explore and zoom in on anything not just in vast space but mainly on Earth, in big and small scales AND in all times in past and future, while the simulation approximately matches our available data (i.e. recorded historical events, famous people, geography, known bodies in the Universe etc.) and procedurally generates/interpolates/extrapolates unknown data (i.e. for example if we don't know what Napoleon did on a certain day, the program will make some guess and show him doing something). This will be the great visual encyclopedia in which one can observe the big bang, [Jesus](jesus.md), dinosaurs, black holes, the future destruction of Earth and so on.
3. **[MMORPG](mmorpg.md)**: Make both client and server for an MMORPG game. The game has to support 3D graphics (but can also have 2D frontends) and have some basic lore that makes sense. Remember, it is MASSIVELY multiplayer game, so you have to be able to handle at least 1000 players connected at the same time on some kind of affordable computer. There must be chat, PvP and PvE combat. Thumbs up for releasing it all under [CC0](cc0.md).

4. **[Python](python.md)**: Implement the Python programming language, INCLUDING its whole standard library. Bonus points for finishing before the version you are implementing stops being supported.
  
  
  
  ____________________________
  
9. **Lorem ipsum [markdown](md.md) generator**: Create a program that generates gibberish text in markdown format that looks like normal human text. Each time it is run, it will generate generally a different text that consists of 3 to 5 sections, each section starts with a heading which starts with `# ` after which 3 to 5 words follow, then there are two newlines and then 3 to 5 paragraphs follow; each paragraph ends with two newlines, except for the last one in the document which only ends with one newline. Paragraph consists of 5 to 10 sentences; each sentence consists of 3 to 10 words, starts with capital letter (other letters are lowercase) and ends with period. About 1 in 20 words in paragraphs are highlighted -- highlight is either italic (the word is between `*`s) or bold (the word is between `**`s). After period there is space except when it's the last period in a paragraph (then there is no space). Words are selected randomly from some set of words that you define (have at least 10 different words). Thumbs up for also generating lists etc.
  
  
  
3. **number [encyclopedia](encyclopedia.md)**: Make a program that writes numbers from 0 to 1000 (including both) and about each of which it writes some facts. These facts have to include at least the number's square, square root, sum of its decimal digits, its [binary](binary.md) representation, prime factorization and whether the number itself is [prime](prime.md), perfect number and [Fibonacci](fibonnaci.md) number.

6. **text adventure**: Make an interactive [CLI](cli.md) text adventure that will take an average player at least 10 minutes to finish. Part of game mechanics must involve inventory, i.e. picking up items, carrying them around and using them.

8. **[bytebeat](bytebeat.md)**: Make at least three cool sounding bytebeat songs.

10. **Caesar cipher**: Make a program that encrypts/decrypts text with the simple cipher known as Caesar cipher, i.e. by offsetting each letter by certain fixed number *N* (e.g. with *N = 2* the letter *A* will become *C*, *B* will become *D* etc.). Assume just ASCII characters on input (encrypted output can be non-ASCII). You can just choose and hardcode some specific *N* but thumbs up for allowing to set any *N*. You can input/output text from/to standard input/output or files -- it's up to you -- also you can either make one program that does both encoding and decoding (e.g. depending on CLI flag) or make two programs, one for each task.
11. **simple website generator**: All static site generators suck ass, make your own. Make a simple markup language and a program that will turn this markup into [HTML](html.md) file -- this will allow you to write HTML websites very easily. The program will read the input file on standard input (i.e. NOT from a file, though you can optionally support this too) and output the HTML on standard output (again, output to file is optional), so that the program can be used like this: `cat myfile.mymarkup | ./mymarkupprocessor > mywebpage.html`. The markup language may be super simple: let's say `_` and `;_` could mark the start and end of bold text (translating to `<b>` and `</b>` respectively) , `#` and `;#` start and end of heading (translating to `<h1>` and `</h1>` respectively) and so on (you can make your own tags, this is just an example). Basically you'll be mostly just translating your tags into HTML tags. You don't have to implement escape sequences for special characters (i.e. it's fine if it's impossible to have let's say the `#` character in your output), but thumbs up if you do. You HAVE TO output a correct HTML, i.e. you have to output a prologue (something like `<html> <head> </head> <body> ...`) and epilogue (something like `</body> </html>`) and somehow deal with possible HTML special characters in the input text: for example if the input contains `<`, you have to translate it to `&lt;` etc., but it is allowed to handle non-trivial cases (like weird Unicode stuff or something) by e.g. just replacing problematic input with `???`. [Unicode](unicode.md) doesn't have to be supported on output, you can output plain [ASCII](ascii.md). You have to support at least normal text, 2 levels of headings and bold text, thumbs up for additional things like images, links, lists etc. Thumbs up for additional features like allowing to set website title with a CLI flag, choose from several hardcoded [CSS](css.md) styles or adding extra output formats like [Markdown](md.md), LaTeX and so on. Test that you generate correct HTML with some HTML validator.
12. **filetype guesser**: Create a program that reads a file and guesses its file type. You can NOT use the file name, only the file content. First look at the [magic number](magic_number.md) (file signature) -- check at least PDF, JPEG, PNG, MP3, GIF and TAR. If this doesn't succeed, then see if 90% of bytes are printable ASCII characters: if so, then guess the file to be TXT, otherwise you may report unknown type (or optionally you can try some extra checks if you want).


### Level 2: Mid, *Hurt Me Plenty*



4. **simple text [compression](compression.md)**: Write a program that can compress and decompress plain [ASCII](ascii.md) text files using some very simple technique like [run length encoding](rle.md) (RLE) or dictionary methods (you can even use a fixed dictionary, e.g. have a list of common English words that you will represent by some shorter symbols). You can assume input characters will only have 7bit ASCII codes, so you can compress the text also by dropping the 8th unused bit. You don't have to achieve great compression ratio (you can even enlarge some files), but you must pass the following test: take the program's source code, this article's plain text and Wikipedia main page plain text, your program must compress at least two of these to a smaller size (and of course successfully decompress them into identical files). The program must work as a [filter](filter.md), i.e. it mustn't load the whole file into memory or perform multiple passes, it has to use approximately same amount of RAM for input of any size.
5. **stupid chatbot**: Make an entertaining chatbot that can react to basic sentences like "how are you?", "are you a robot?", "tell me a joke" and so on. It must give a human-like answer to at least 50 different sentences. It has to deal with typos and text variability a little bit (for example multiple spaces in a row or all caps text mustn't confuse it). It must have a mood meter which changes depending on what the partner says -- for example if the bot gets insulted, it gets more angry and starts inserting profanity to responses; on the other hand if it's happy it will insert nice smiley faces etc. The bot also has to remember and use the name of its chat partner if that is brought up. Test the bot by having it chat with itself.

7. **arbitrary size [rational numbers](rational_number.md)**: Make a library that allows working with arbitrary size rational numbers, i.e. represent each number as a pair of numerator and denominator, the number will be automatically allocating itself as much memory as it needs for storing the two internal values. Negative numbers must be supported too. It mustn't waste too much memory, i.e. whenever it changes, it will try to simplify the fraction and, if possible, decrease its size and allocate less memory. Size of the number will only be limited by amount of RAM your program can use. Furthermore implement these operations with the numbers: converting to/from the language's native numbers (with rounding if necessary), comparisons (equal, greater, greater or equal, smaller, smaller or equal), addition, subtraction, multiplication, division and printing and/or converting the number to string (at least decimal -- if the number has infinitely many fractional digits, just cut the output somewhere).
8. **image to [ASCII art](ascii_art.md)**: Make a program that takes an RGB bitmap image and renders it with ASCII characters (i.e. prints it out to console). You can support loading the image from just one file format of your choice, possibly something simple like PPM, BMP or Farbfeld. The program must support resizing the image and it must allow to just set one dimension with keeping the aspect ratio. Thumbs up for extra features like setting brightness/contrast and so on.
9. **[pseudorandom](pseudorandom.md) tester**: Make a command line program that will test the quality of a pseudorandom generator by reading an input of bytes and performing some statistical tests on them. You have to implement at least four of the following tests: mean value of the whole sequence, ratio of 1 and 0 bits, histogram (count of each value), chi square test, correlation of consecutive values (how much a value depends on the previous one), density plot (using ASCII art) of the bytes interpreted as [X,Y] coordinates (i.e. basically a 2D histogram), monte carlo computation of some constant such as pi (with comparison to the perfect value), interpreting part of the data as rows of pixels and drawing them (with ASCII art). Of course you may implement more fancy tests. You may impose reasonable limits in your measuring (for example you don't have to report all measures absolutely precisely, for example we don't have to know exact counts of 1 bits and 0 bits, only their approximate ratio), just make the tool usable for its purpose. Test your program on data from /dev/urandom (should conclude it's random) and some non-random data, for example some txt book from Project Gutenberg.
10. **educational [sorting](sorting.md) visualization**: Make a program for visualizing sorting algorithms -- it may draw real graphics (either directly to the screen or by outputting animation file) or just render ASCII art graphics, but it has to clearly show what the sorting algorithm is doing, i.e. which elements are being compared, which are swapped and if it makes good sense to highlight something else (like the pivot or already sorted part of the array), you should do it. Implement at least bubble sort, insertion sort, selection sort and quick sort. Also offer benchmark mode in which all algorithms race in sorting the same array (this can be without advanced visualization, just show e.g. number of steps for each).
11. **3D model of [fractal](fractal.md)**: Make a program that outputs 3D model of either Siepinski triangle or Koch snowflake fractal. The output shall be some simple 3D format like obj or Collada. The model can be primitive, i.e. it can be just flat shape made of triangles which don't have to really be connected, but the program must allow specifying the number of iterations of the fractal (during invocation, e.g. as a CLI flag). Check that the model is correct by opening it in some 3D editor such as Blender.
12. **[steganography](steganography.md)**: Make a program that hides text strings in either pictures, sounds or another text. The program must be a nice [CLI](cli.md) utility that performs both encoding and decoding -- it will allow the user to specify the string to hide (this string can be simplified to take less space, e.g. it may be converted to all caps, special characters may be removed etc.) and the data in which to embed them. The size of the string that can be encoded will of course be limited by how much space there is in the data, so you can reject or shorten the string if that's the case. The string must NOT be hidden in metadata (i.e. exif tags, file header, after the data, ...), it must be encoded in the useful data itself, i.e. in pixels of the picture, samples of the sound or characters of the text, but it mustn't be apparent that there is something hidden in the data. Use some simple technique, for example in images and sound you can often change the least significant bits without it being noticed, in text you can insert typos, hyphens, replace some periods with semicolons etc. Get creative.


### Level 3: Hard, *Ultra Violence*

1. **[quine](quine.md) master**: Without looking it up, write a quine in one language and radiation hardened quine in another language. Quine is a program that outputs its own source code (don't cheat, you can't read it from the source file), radiation hardened quine is a quine that remains a quine if you remove any single character from the program.
2. **non-trivial [programming language](programming_language.md)**: Design language *L*, write its specification and make a self hosted interpreter and/or compiler for it, i.e. write *L* in *L* (for this you may first have to write it in another language). *L* must be [Turing complete](turing_complete.md) and you have to provide mathematical proof of it. *L* must allow [recursive](recursion.md) function calls. It must not support native [OOP](oop.md). *L* must be usable for programming very basic things -- show it is so by writing [bubble sort](bubble_sort.md) in it. Write [quine](quine.md) in it. Thumbs up for also making a compiler.

4. **textured 3D [software renderer](sw_rendering.md)**: Make 3D software renderer that rasterizes triangles (just like for example [OpenGL](ogl.md)), with texturing. Affine texture mapping (i.e. the easier, incorrect texturing by linear interpolation of texturing coordinates in screen space) will pass, but thumbs up for perspective correct texture mapping. Implement some basic [shading](shading.md) like, e.g. Goraud with ambient and diffuse light. You have to handle visibility even of non-convex shapes, e.g. with z-buffer or at least approximately by sorting triangles. It's enough if you can display some textured model with setting camera position and rotation somehow. You don't have to handle any 3D formats, 3D models can just be passed as arrays of numbers (same with textures). It is enough if you output static images e.g. to a file, but thumbs up for being able to handle real-time rendering, animation and having extra features like transparency, scene graph and so on. Extra thumbs up for not using [float](float.md).


7. **bitmap image editor**: [GIMP](gimp.md) is bloated! You have to save us by writing a GUI image editor that's at least a bit more advanced than the original MS paint. It has to be able to save and load images (supporting just one format is enough), draw basic shapes (at least a line, rectangle and circle), copy/paste parts of the image (with rectangle select), resize the image as a whole (with scaling it), have fill bucket and adjust brightness and contrast of the whole image. It should be reasonably user friendly, i.e. upon quitting it should ask if you want to save the work, it must have some basic help etc. Thumbs up for extra features like filters (blur, invert, edge detect, ...), layers and so on.
8. **64K intro**: Make an impressive [demoscene](demoscene.md)-style 3D intro with music. It must have duration of at least 1 minute and fit into a 64 KB executable. It has to be good enough so that an average demoscener would approve it as not completely laughable.
9. **3D [path tracer](path_tracing.md) without [floating point](float.md)**: Write a path tracer (NOT a mere [ray tracer](ray_tracing.md)) without using floating point. It can only produce static images that may just be saved to a file in some simple format (no need to draw real time animation to the screen). It must be possible to position and rotate the camera arbitrarily and to set its field of view. It has to support several shapes of objects in the scene: at least a sphere, plane and cylinder, and it must support transparent objects. Thumbs up for supporting polygonal models, depth of field and loading scene description from a file.
10. **[gopher](gopher.md) fulltext search engine**: Create a whole search engine (with crawler, index creator, user frontend, ...) for the gopher network. It can store its database just to flat files (no need to use SQL or something like that). It has to allow at least very basic fulltext search, i.e. about each gopher site you'll have to remember which words it contains (and possibly their count), so that if the user searched e.g. for `cats dogs`, you'll give him sites that contain both of these words somewhere in their text -- offer options to search either for sites containing all searched words or just some of them. Besides this you can make simplifications (ignore case, don't support Unicode, special characters etc.). Thumbs up for additional features like creating a graphical map of the crawled gopherspace along the way.
11. **[Jpeg](jpg.md) clone**: Create a usable format for photo images with lossy [compression](compression.md), similar to [Jpeg](jpg.md), that achieves good compression ratio and allows setting compression level, including setting compression level 0 (when it will only apply lossless compression). The format doesn't have to store any metadata, it's enough if it holds a 24 bit RGB bitmap of arbitrary resolution. For compression it must do at least following: separating the color and intensity channel and subsampling the color channel (see e.g. [YCbCr](ycbcr.md)), then converting the image to frequency domain (probably with [discrete cosine transformation](dct.md)) and quantizing the high frequencies, and then applying at least some lossless compression (RLE or Huffman coding or something). You can't use any libraries to do the described things (e.g. DCT, color conversion etc.), do it all yourself. The program, with medium compression level set, has to beat lz4 at compressing photos at least 90% times (in theory it should win always but we'll give you some margin if you fuck something up).

13. **console [emulator](emulation.md)**: Make an emulator of either [PlayStation 1](ps1.md), Nintendo64, GameGear or any version of [GameBoy](gameboy.md) (GB, GBC or GBA). You can use a library for 3D rendering if you need it. You don't have to implement networking or weird/non-standard features (like light sensor etc.). You don't have to achieve high accuracy but at least a few games should be playable. You have to allow saving/loading game states. Sound support can be basic.
14. **[genetic programming](genetic_programming.md)**: Create a [KISS](kiss.md) genetic programming framework. Make some kind of simple, low level model of computation, its language (something like Turing machine, brainfuck, Forth etc.) and its interpreter, then implement firstly generating random programs, secondly randomizing (mutating) existing programs and thirdly combining existing programs (creating offspring). Now create a system that will spawn a population of random programs and will then direct its evolution by generations toward optimizing performance at some given task -- this performance will be measured by fitness function (which will somehow score any given program depending on how well it's working) that will be customizable in your framework, i.e. anyone must be easily able to rewrite the fitness function to whatever he desires (it's okay if changing fitness function requires recompilation of your program). In each generation your framework will remove badly performing programs, breed new programs by combining well performing ones, randomly mutate some programs and add in a few new completely random programs -- specific parameters of this must also be curstomizable (again, recompilation here is okay). Test this by evolving some simple program (solving a maze, quadratic equation, blurring an image or something similar).



TODO: tetris, voice synth?, snake, quadratic equation, fractals, 2D raycasting, fourier transform, primes, image library, web browser, diff, HTML parser/visualizer?, markov chain, syntax beautifier, grep, some kinda server, function plotter, pi digits, 2D physics engine, encryption?, custom markup lang, procedural MIDI, machine translation?, maze gen., genetic prog., language recognizer, AI?, photogrammetry, solar system simulator, emulator, chat (P2P?), auto integrator, steganography, driver? ...
